#!/usr/bin/env python

"""
Generate VHDL code from HTI XML register description documents.

This program parses two different types of XML description file.
First, a file documenting a single component, and all of the
registers that it may contain.  Second, a file documenting an
overall memory map, which instantiates and calls out various
components.

"""

import textwrap
import datetime
import argparse
import traceback
import codecs
import os
import sys
import itertools
import math
from StringIO import StringIO

import space
from hti_reg_xml import *

class OutputterError(Exception):
    """
    An error because the outputter doesn't know what to do.
    First argument is a string description, second is the
    HtiElement where the error occurred.
    """
    pass
    
class CommentFormatter:
    """Accept an array of lines, formats them as a comment between full -- bars"""
    tw = textwrap.TextWrapper(
        initial_indent = "",
        subsequent_indent = ""
    )
    
    def __init__(self, start='--  ', width=79, bars=True, indent = 0):
        self.bars = bars
        self.width = width
        self.start = start
        self.indent = indent
        
    def format(self, text):
        """
        Format a list of lines between horizontal bars.
        """
        
        if (self.bars):
            bar = (' ' * self.indent) + ('-' * (self.width - self.indent))
        else:
            bar = None
        
        start = (' ' * self.indent) + self.start
        self.tw.width = self.width - len(start)
        
        comment = [bar]
        for line in text.strip().splitlines():
            wrapped_lines = self.tw.wrap(line)
            if wrapped_lines:
                comment.extend([start + l for l in wrapped_lines])
            else:
                comment.append(start)
        comment.append(bar)
        
        return "\n".join(comment)

cf = CommentFormatter()

########################################################################
# General purpose output formatting stuff
########################################################################

def register_format(element, index=True):
    fmt = element['format']
    
    if element.bitWidth() == 1:
        return 'std_logic'
    
    if fmt in ('signed', 'unsigned'):
        basetype = fmt
    else:
        basetype = 'std_logic_vector'
    
    if index:
        return '{0}({1} downto 0)'.format(basetype, element.bitWidth()-1)
    else:
        return basetype
    
def make_vhdl_filename(output_dir, sourcefile):
    """The name of a VHDL file generated by a given source file."""
    basename = os.path.basename(sourcefile)
    (root, ext) = os.path.splitext(basename)
    basename = root + ".vhd"
    
    if output_dir:
        return os.path.join(output_dir, basename)
    else:
        return basename

def recordType(name, fields):
    """
    Generate the output string for a record type.
    
    Keyword Arguments:
    name - The name of the record type
    fields - An iterable of tuples, (ElementName, ElementType), similar
    to constructing a dict.
    
    >>> print recordType('foo', (
    ...    ('bar1', 'std_logic_vector(15 downto 0)'),
    ...    ('bar2', 'std_logic_vector(8 downto 0)')
    ...    ))
    type foo is record
        bar1 : std_logic_vector(15 downto 0);
        bar2 : std_logic_vector(8 downto 0)
    end record foo;
    """
    
    maxlen = max(len(x[0]) for x in fields)
    
    contents = ('    {f:{l}s} : {t};'.format(
                        f = x[0],
                        t = x[1],
                        l = maxlen
                    ) for x in fields)
    
    return ("type {0} is record\n".format(name) +
            "\n".join(contents)                +
            "\nend record {0};".format(name))
                          
########################################################################
# Routines for outputting Components
########################################################################

#
# Add names to all of the registers
#

def make_register_name(self, compname):
    self.regname = self['name']
    
def make_regarray_name(self, compname):
    self.regname = self['name']
    for r in self.space.getObjects():
        r.make_name(self.regname)

Register.make_name      = make_register_name
RegisterArray.make_name = make_regarray_name

#
# We need to generate address constants for the registers.
#

def generate_register_address(self, addresstype, output):
    print >>output, "constant {name:30s}: {addr} := 16#{offset:03X}#;".format(
                        name = self.regname + '_ADDR',
                        addr = addresstype,
                        offset = self['offset'])
    
    
def generate_regarray_address(self, addresstype, output):
    print >>output, detab("""
        constant {basename:30s}: {addr} := 16#{baseoffset:03X}#;
        constant {lastname:30s}: {addr} := 16#{lastoffset:03X}#;
        constant {framename:30s}: {addr} := 16#{framesize:03X}#;
        """).format(
            basename = self.regname + '_BASEADDR',
            lastname = self.regname + '_LASTADDR',
            framename = self.regname + '_FRAMESIZE',
            addr = addresstype,
            baseoffset = self['offset'],
            lastoffset = self['offset'] + self['size'] - 1,
            framesize = self['framesize'])
                        
    for r in self.space.getObjects():
        r.generate_address(addresstype, output)
    
Register.generate_address       = generate_register_address
RegisterArray.generate_address  = generate_regarray_address
    
#
# We need to generate (sub)types for all the registers.
#

def generate_field_enums(self, regname, output):
    
    if not self.space:
        return
        
    enums = list(self.space.getObjects())
    maxlen = max(len(e['name']) for e in enums)
    
    for e in enums:
        print >>output, 'constant {regname}_{fieldname}_{name:{len}s} : {vhdltype} := "{val:0{width}b}";'.format(
                                    regname = regname,
                                    fieldname = self['name'],
                                    name = e['name'], len = maxlen,
                                    vhdltype = self.vhdl_type,
                                    val = e['value'], width = self['size'])
    print >>output
    
Field.generate_enums        = generate_field_enums

def generate_register_type(self, output):
    """
    Output a type or subtype definition for this register.
    Also, create the .vhdl_type member.
    """
    
    regname = self['name']
    self.vhdl_type = 't_' + regname
    
    comment = [regname]     # Build up a nice big running comment array
    desc = self.textDescription()
    if desc:
        comment.append(desc)

    if self.has_fields:
        # We'll put all of the comment information for a given register into 
        # one big comment block.  Otherwise it all gets way too broken up.
        
        # Pick up all the fields in bit-ascending order
        fields = tuple(self.space.getObjects())
        
        comment.append("")
        comment.append("Defined fields:")
        comment.append("---------------")
        for f in reversed(fields):
            comment.append(f['name'] + " - " + f.textDescription() + "\n")
        
    print >>output, cf.format("\n".join(comment))
        
    if self.has_fields:
        # Generate a structure for this register.
        maxlen = max(len(f['name']) for f in fields)
        
        for f in fields:
            f.vhdl_type = register_format(f)
            
        contents = tuple((f['name'], f.vhdl_type) for f in fields)
        print >>output, recordType(self.vhdl_type, contents)
        print >>output
        
        # This is a good place to put all of the enumerations too.
        for f in fields:
            f.generate_enums(regname, output)
        
    else:
        print >>output, 'subtype {0} is {1};'.format(self.vhdl_type, register_format(self))
        print >>output
    
            
def generate_regarray_type(self, output):
    """
    Output a type or subtype definition for this register.
    Also, create the .vhdl_type member.
    """
    sub = list(self.space.getObjects())
    
    for obj in sub:
        obj.generate_type(output)
    
    # Create a record type for the elements of the array if needed.
    if len(sub) == 1:
        basetype = sub[0].vhdl_type
    else:
        basetype = 'tb_' + self['name']
        print >>output, recordType( basetype, 
                                    tuple((x['name'], x.vhdl_type) for x in sub))
                            
    # And create our array type
    self.vhdl_type = 'ta_' + self['name']
    
    print >>output, 'type {ta} is array({top} downto 0) of {tb};'.format(
                        ta = self.vhdl_type,
                        top = self['count'] - 1,
                        tb = basetype)
    
Register.generate_type      = generate_register_type
RegisterArray.generate_type = generate_regarray_type
    
#
# We need to generate access functions for all the registers.
#

def generate_field_read_function(self, output):
    """Translate this field to the bus."""
    if (self['size'] > 1):
        print >>output, "    ret({high} downto {low}) := std_logic_vector(dat.{name});".format(
                        name = self['name'],
                        high = self['size'] + self['offset'] - 1,
                        low = self['offset'])
    else:
        print >>output, "    ret({loc}) := dat.{name};".format(
                        name = self['name'],
                        loc = self['offset'])
                            
def generate_field_write_function(self, output):
    """Translate this field from the bus."""
    if (self['size'] > 1):
        print >>output, "    ret.{name} := {format}(wb({high} downto {low}));".format(
                        name = self['name'],
                        format = register_format(self, index=False),
                        high = self['size'] + self['offset'] - 1,
                        low = self['offset'])
                        
    else:
        print >>output, "    ret.{name} := wb({loc});".format(
                        name = self['name'],
                        loc = self['offset'])
                        
Field.generate_read_function = generate_field_read_function
Field.generate_write_function = generate_field_write_function
                    
def generate_register_functions(self, output):
    """Write input and output functions for this register."""
    if self.has_fields:
        # Have to iterate against the record type.
        
        print >>output, detab("""
            pure function {regname}_TO_WB(dat : t_{regname}) return t_wb_data is
                variable ret : t_wb_data;
            begin
                ret := (others => '0');
            """).format(regname = self.regname)
            
        for c in self.space.getObjects():
            c.generate_read_function(output)
            
        print >>output, detab("""
                return ret;
            end function {regname}_TO_WB;
            
            """).format(regname = self.regname)
                
        print >>output, detab("""
            pure function WB_TO_{regname}(WB_IN : t_wb_mosi; current_dat : t_{regname}) return t_{regname} is
                variable wb  : t_wb_data;
                variable ret : t_{regname};
            begin
                wb := {regname}_TO_WB(current_dat);
                wb := select_data(wb, WB_IN);
            """).format(regname = self.regname)
            
        for c in self.space.getObjects():
            c.generate_write_function(output)
            
        print >>output, detab("""
                return ret;
            end function WB_TO_{regname};
            
            """).format(regname = self.regname)
            
    elif (self.bitWidth() == 1):
        # Only one single bit
        print >>output, detab("""
            pure function {regname}_TO_WB(dat : t_{regname}) return t_wb_data is
                variable ret : t_wb_data;
            begin
                ret := (0 => dat, others => '0');
                return ret;
            end function {regname}_TO_WB;
        
            pure function WB_TO_{regname}(WB_IN : t_wb_mosi; current_dat : t_{regname}) return t_{regname} is
                variable wb  : t_wb_data;
                variable ret : t_{regname};
            begin
                wb := {regname}_TO_WB(current_dat);
                wb := select_data(wb, WB_IN);
                ret := wb(0);
                return ret;
            end function WB_TO_{regname};
        #kmod...    
			procedure UPDATE_{regname}(reg : inout t_{regname}; nd : in t_wb_mosi; be : in t_be) is
            begin
                if (be(0) = '1') then
                    reg := nd(0);
                end if;
            end procedure UPDATE_{regname};
            """).format(
                    regname = self.regname
                )
        
    else:  
        # Just have to work with the subtype.
        print >>output, detab("""
            pure function {regname}_TO_WB(dat : t_{regname}) return t_wb_data is
                variable ret : t_wb_data;
            begin
                ret := (others => '0');
                ret(dat'range) := std_logic_vector(dat);
                return ret;
            end function {regname}_TO_WB;
        
            pure function WB_TO_{regname}(WB_IN : t_wb_mosi; current_dat : t_{regname}) return t_{regname} is
                variable wb  : t_wb_data;
                variable ret : t_{regname};
            begin
                wb := {regname}_TO_WB(current_dat);
                wb := select_data(wb, WB_IN);
                ret := {format}(wb(ret'range));
                return ret;
            end function WB_TO_{regname};
            
            """).format(
                    regname = self.regname,
                    format = register_format(self, index=False)
                )

def generate_regarray_functions(self, output):
    for obj in self.space.getObjects():
        obj.generate_functions(output)

Register.generate_functions         = generate_register_functions
RegisterArray.generate_functions    = generate_regarray_functions
        
def generate_register_function_prototype(self, output):
    """Generate the function prototypes for a single register."""
    print >>output, detab("""
            pure function {regname}_TO_WB(dat : t_{regname}) return t_wb_data;
            pure function WB_TO_{regname}(WB_IN : t_wb_mosi; current_dat : t_{regname}) return t_{regname};
            """).format(regname = self.regname)
            
def generate_regarray_function_prototype(self, output):
    for obj in self.space.getObjects():
        obj.generate_function_prototype(output)
    
Register.generate_function_prototype        = generate_register_function_prototype
RegisterArray.generate_function_prototype   = generate_regarray_function_prototype
    
#
# We need to generate all of the above for a component.
#

def generate_single_component(comp, output=sys.stdout):
    """Render down a component tree into a VHDL package."""
    
    compname = comp['name'].lower()

    header = detab("""
        {name} Register Map
        Defines the peripherals on the {name} memory map.
        
        {desc}
        
        Generated automatically from {source} on {time}
        Do not modify this file directly.
        """)
            
    print >>output, cf.format(header.format(
            name = comp['name'],
            desc = comp.textDescription(),
            source = comp.sourcefile,
            time = datetime.datetime.now().ctime()
        ))
    
    header = detab("""
        library IEEE;
        use IEEE.STD_LOGIC_1164.all;
        use IEEE.NUMERIC_STD.all;
        use IEEE.STD_LOGIC_MISC.all;
            
        use work.pkg_global.all;

        -----------------------------------------------------------------------------
        -- PACKAGE DECLARATIONS
        -----------------------------------------------------------------------------         
        
        package pkg_{name} is
        """).format(name = compname)   
    print >>output, header

    # Bind complete names for all the registers
    for c in comp.children:
        c.make_name(comp['name'])

    print >>output
    print >>output, cf.format("---------------- Register Addresses ----------------")
    print >>output
    
    # Create an address constant type.
    addresstype = 't_addr'
    print >>output, 'subtype {name} is integer range 0 to {top};'.format(
                        name = addresstype,
                        top = comp['size'] - 1)
    
    # Create address constants for all the registers.
    for obj in comp.space.getObjects():
        obj.generate_address(addresstype, output)
    
    print >>output
    print >>output, cf.format("---------------- Register Types ----------------")
    print >>output
    
    # Create types for all the registers.
    for obj in comp.space.getObjects():
        obj.generate_type(output)
   
    print >>output
    print >>output, cf.format("---------------- Access Functions ----------------")
    print >>output
    
    # The most useful access function pulls the address from the WISHBONE
    print >>output, "pure function GET_ADDR(WB_IN : t_wb_mosi) return {addr};".format(
                            addr = addresstype,
                            msb = int(math.ceil(math.log(comp['size'], 2))) - 1
                        )
    
    for obj in comp.space.getObjects():
        obj.generate_function_prototype(output)
    
    print >>output, detab("""
        end package PKG_{name};

        -----------------------------------------------------------------------------
        -- PACKAGE BODY
        -----------------------------------------------------------------------------     
        
        package body PKG_{name} is
        """).format(name = comp['name'])
        
    print >>output, detab("""
        pure function GET_ADDR(WB_IN : t_wb_mosi) return {addr} is
        begin
            return TO_INTEGER(WB_IN.ADDR({msb} downto 0));
        end function GET_ADDR;
        """).format(
            addr = addresstype,
            msb = int(math.ceil(math.log(comp['size'], 2))) - 1
        )
        
    for obj in comp.space.getObjects():
        obj.generate_functions(output)
        
    print >>output, detab("""
        end package body PKG_{name};
        """).format(name = comp['name'])

Component.generate = generate_single_component

########################################################################
# Routines for outputting MemoryMaps
########################################################################

#
# We need to generate address ranges for each instance on the map.
#

def generate_inst_address(self, mapname, output):
    
    instname = mapname + '_' + self['name']
    
    print >>output, detab("""
                    constant {name}_LOW  : integer := {start};
                    constant {name}_HIGH : integer := {end};
                    """).strip().format(
                        name = instname,
                        start = self['offset'],
                        end = self['offset'] + self['size'] - 1)
    print >>output

def generate_instarray_address(self, mapname, output):
    raise OutputterError("Can't deal with instance arrays.", self)
    
Instance.generate_address       = generate_inst_address
InstanceArray.generate_address  = generate_instarray_address

#
# We need to generate all of the above for a memory map.
#

def generate_memory_map(self, output=sys.stdout):
    """Render down a memory map into a VHDL package."""
    
    header = detab("""
        {name} Register Map
        Defines the registers in the {name} component.
        
        {desc}
        
        Generated automatically from {source} on {time}
        Do not modify this file directly.
        """).format(
            name = self['name'],
            desc = self.textDescription(),
            source = self.sourcefile,
            time = datetime.datetime.now().ctime()
        )
            
    print >>output, cf.format(header)
    
    packagename = 'pkg_' + self['name'].lower()
    
    header = detab("""
        library IEEE;
        use IEEE.STD_LOGIC_1164.all;
        use IEEE.NUMERIC_STD.all;
        use IEEE.STD_LOGIC_MISC.all;
            
        use work.pkg_global.all;

        package {name} is
        """).format(name = packagename)
            
    print >>output, header

    # Generate address ranges
    
    for obj in self.space.getObjects():
        obj.generate_address(self['name'], output)
    
    footer = detab("""
        end package {name};

        package body {name} is
        end package body {name};
        """).format(name = packagename)
        
    print >>output, footer

MemoryMap.generate = generate_memory_map

########################################################################
# Main code
########################################################################

def output_select(output_dir, sourcefile):
    """If output_dir is non-null, produce a context manager for
    an output file, with the name derived from output_dir and sourcefile.

    Otherwise, produce a context manager that simply wraps
    the standard output stream.

    """
    class StdoutWrapper:
        def __enter__(self):
            return sys.stdout

        def __exit__(self, type, value, traceback):
            return

    if output_dir:
        return open(make_vhdl_filename(output_dir, sourcefile), 'w')

    else:
        return StdoutWrapper()
        
def main(argv=None):
    ########################################################
    # Start by parsing the command line options.
    ########################################################
    if argv is None:
        argv = sys.argv[1:]

    ap = argparse.ArgumentParser(description=__doc__)
    ap.add_argument('--output-dir', '-o', help="""
        When present, specifies a directory to write output files to.
        Output files will have the same names as the input files they
        correspond to, but with a .vhd extension, rather than .xml.
        When absent, all output will be written to stdout.
        """)
    ap.add_argument('--no-mmap', '-m', action="store_false", dest = 'mmap', help="""
        Ignore any memory map files; generate only component
        files.
        """)
    ap.add_argument('source', nargs = '+', help="""
        Input files in the HTI XML register or memory map description
        format.
        """)

    args = ap.parse_args(argv)

    if (args.output_dir and not os.path.isdir(args.output_dir)):
        print >>sys.stderr, "Unable to write to directory {0}".format(args.output_dir)
        sys.exit(1)

    ########################################################
    # Read all the XML files
    ########################################################

    parser = XmlReader()
    components = []
    maps = []
    codec = codecs.lookup('utf-8')[-1]

    for source in args.source:
        try:
            root = parser.Parse(source)
            if isinstance(root, Component):
                root.finish()
                components.append(root)
            
            elif isinstance(root, MemoryMap):
                maps.append(root)
                
        except:
            print >>sys.stderr, "Error parsing {0}".format(source)
            traceback.print_exc()

    ########################################################
    # Bind the output methods
    ########################################################
    
    HtiElement.textDescription = lambda self: "\n\n".join(self.getDescription())
    
    def register_width_fn(self):
        if self.space:
            fields = [f for f in self.space.getObjects()]
            if len(fields) == 1:
                return fields[0]['size']
        
        return self['width']
    
    Register.bitWidth = register_width_fn
    Field.bitWidth = lambda self: self['size'] 

    ########################################################
    # And generate all of the outputs
    ########################################################

    if maps and args.mmap:
        cmap = MemoryMap.build_component_map(components)
        
        for mmap in maps:
            mmap.finish(cmap)
            
        components.extend(maps)
            
    for obj in components:
        with output_select(args.output_dir, obj.sourcefile) as target:
            try:
                obj.generate(output = codec(target))

            except OutputterError as e:
                print >>sys.stderr, e.args[0]
                print >>sys.stderr, '    Sourced from {0}, line {1}'.format(
                                    e.args[1].sourcefile,
                                    e.args[1].sourceline)
                    
            except:
                print >>sys.stderr, "Unknown error parsing {0}, sourced from {1}".format(
                    obj['name'], obj.sourcefile)
                traceback.print_exc()

if __name__ == "__main__":
    sys.exit(main())
