#!/usr/bin/env python

"""
Generate Python header files from HTI XML register description documents.

The header files are based around ctypes and our bitfield module.

This program parses two different types of XML description file.
First, a file documenting a single component, and all of the
registers that it may contain.  Second, a file documenting an
overall memory map, which instantiates and calls out various
components.

The structure of the program is to attach new outputter methods
to the classes defined by hti_reg_xml, and then call those methods
on the objects they're bound to.  This seems a bit overly
complicated, but is the cleanest way to deal with the existance
of Arrays, which may nest arbitrary arguments.
"""

import textwrap
import datetime
import argparse
import traceback
import codecs
import os
import sys
import itertools
from StringIO import StringIO

import space
from hti_reg_xml import *

class OutputterError(Exception):
    """
    An error because the outputter doesn't know what to do.
    First argument is a string description, second is the
    HtiElement where the error occurred.
    """
    pass

########################################################################
# Much to do to enable good looking comments in the output.
########################################################################

class Indenter:
    """Accept an array of lines, formats them as indented text."""
    tw = textwrap.TextWrapper(
        initial_indent = '',
        subsequent_indent = ''
    )

    def __init__(self, width=79, indent = 0):
        self.width = width
        self.indent = indent

    def __call__(self, text):
        """
        Format a list of lines as a docstring.
        """

        indent = ' ' * self.indent
        self.tw.width = self.width - self.indent
        wrapped_lines = sum(
            (self.tw.wrap(line) if line else [''] for line in text)
            , []
        )
    
        return "\n".join(indent + line for line in wrapped_lines)

docstring = Indenter(indent = 0)
docstring_indented = Indenter(indent = 4)

########################################################################
# General purpose output formatting stuff
########################################################################

def register_format(reg):
    """Return the storage specification for a given register."""
    x = reg.get('bf_format', None)
    if x: return x
    
    if (reg.get('format', '').lower() == 'signed'):
        return 'c_int32'
    else:
        return 'c_uint32'

def make_header_filename(output_dir, sourcefile):
    """The name of a header file generated by a given source file."""
    basename = os.path.basename(sourcefile)
    (root, ext) = os.path.splitext(basename)
    basename = root.lower() + ".py"
    
    if output_dir:
        return os.path.join(output_dir, basename)
    else:
        return basename

def define(name, val):
    return '#define {0:39s} ({1})'.format(name, val)

########################################################################
# Routines for outputting Components
########################################################################

#
# We need to output structs from (Arrays of) Registers.
#

def generate_struct_innards(space, indent, output):
    """Generates the interior bits of struct from a space full of Registers."""
    for ptr in space:
        if ptr:
            # Real element
            print >>output, indent + "('{name}', {fmt}),".format(
                name = ptr.obj['name'].lower(), 
                fmt = register_format(ptr.obj)
            )
        else:
            # Gap
            print >>output, indent + "('_dummy{n}', c_uint32 * {size}),".format(
                n = ptr.pos,
                size = ptr.size
            )

#
# We need to output bitfields from (Arrays of) Fields
#

def generate_bitfields(space, compname, output):
    """Generate the bitfields for the space, with as much recursion as necessary."""
    for ptr in itertools.ifilter(bool, space):
        if ptr.obj.space:
            ptr.obj.generate_bitfields(compname, output)
   
def generate_array_bitfields(self, compname, output):
    """Generate bitfields for all contained fields and an array type for us."""
    generate_bitfields(self.space, compname, output)
    
    # Create the array type
    typename = '_' + self['name'] + '_array'
    self['bf_format'] = typename
    
    if len(self.space) > 1:
        # We need yet another structure to represent the internals
        intltype = typename + '_intl'
        generate_struct(self, intltype, output)
    else:
        intltype = register_format(self.space[0].obj)
        
    print >>output, "{name} = {intl} * {count}".format(
        name = typename,
        intl = intltype,
        count = self['count']
    )
             
def generate_register_bitfields(self, compname, output):
    """Generate bitfields for the contained fields."""
    
    if len(self.space) <= 1: return 
    
    # Create the bitfield type
    typename = '_' + self['name']
    self['bf_format'] = typename
    fields = []
    dummy_cnt = 0
    docs1 = self.getDescription()
    docs1.extend(['', 'Subfields:'])
    docs2 = []
    
    for field in self.space:
        if field:
            fieldname = field.obj['name'].lower()
            fieldfmt = register_format(field.obj)
            
            subdocs = field.obj.getDescription() or ['']
            subdocs[0] = fieldname + ' - ' + subdocs[0]
            docs2.extend(subdocs)
            docs2.append('')
            
        else:
            fieldname = '_dummy' + str(dummy_cnt)
            fieldfmt = 'c_uint'
            dummy_cnt += 1
            
        fields.append("('{0}',{1},{2})".format(fieldname, fieldfmt, field.size))
    
    print >>output, "fields = [{0}]".format(','.join(fields))
    print >>output, 'docstring = """\n', docstring(docs1), '\n', docstring_indented(docs2), '\n"""'
    print >>output, "{name} = make_bf('{name}', fields, c_uint32, docstring)".format(
        name = typename,
    )
    
    # Append any enumeration definitions
    enumerated_fields = (f for f in self.space.getObjects() if f.space)
    for field in enumerated_fields:
        field
        enums = (
            '{name}.{field}_{enum} = {val}\n'.format(
                name = typename,
                field = field['name'].upper(),
                enum = e['name'].upper(),
                val = e['value']
            ) for e in field.space.getObjects()
        )
        output.writelines(enums)
    
    print >>output, ''
    
RegisterArray.generate_bitfields = generate_array_bitfields
Register.generate_bitfields = generate_register_bitfields
                                   
#
# We need to output Components, which will be a typedef and a mess o'
# #define for any bitfields.
#
                                   
def generate_single_component(comp, output, standalone = True):
    """
    Render down a component tree into a Python module.
    
    Keyword Arguments:
    comp - A Component to generate the header from.
    
    output - A file-like object to write the results to
    
    standalone - If True (default), generate this component as if it's
    a standalone file, complete with #ifdef protection, #includes, etc.
    If False, skip all this.
    """

    header = detab("""
        '''
        {name} Register Map
        Defines the registers in the {name} component.
        {desc}
        Generated automatically from {source} on {time}
        Do not modify this file directly.
        '''
        """).format(
            name = comp['name'],
            desc = comp.textDescription(),
            source = comp.sourcefile,
            time = datetime.datetime.now().ctime()
        )
    print >>output, header

    if standalone:
        header = detab("""
            from ctypes import *
            from bitfield import *
            
            """)
        print >>output, header

    # First, generate all our bitfield subtypes.
    generate_bitfields(comp.space, comp['name'], output)
    
    # Then put together our overarching structure
    generate_struct(comp, comp['name'], output)
     
def generate_struct(comp, name, output):
    template = detab('''
    
        class {name}(LittleEndianStructure):
            """
        {docstring}
            """
            pass
        
        {name}._fields_ = [
        '''
    )
    print >>output, template.format(
        name = name,
        docstring = docstring_indented(comp.getDescription())
    )
    
    generate_struct_innards(comp.space, '    ', output)
    print >>output, ']'

Component.generate = generate_single_component

########################################################################
# Routines for outputting MemoryMaps
########################################################################
    
#
# We need to output base addresses.
#
    
def generate_baseaddrs(space, basename, output):
    """Create base address definitions."""
    for ptr in itertools.ifilter(bool, space):
        # We don't actually care whether it's the base of an array or an instance
        desc = ptr.obj.textDescription()
        if desc:
            print >>output, subcomment.format(desc)
        
        print >>output, define(
            name = basename + '_' + ptr.obj['name'] + '_BASE',
            val = '{0}_BASE + 0x{1:08X}u'.format(basename, ptr.pos));
  
#
# We need to output structure pointers to peripherals.
#

def generate_peripherals(space, basename, output):
    """Create peripheral pointer definitions."""
    
    for ptr in itertools.ifilter(bool, space):
        ptr.obj.generate_peripherals(basename, output)
   
def generate_array_peripherals(self, basename, output):
    """Create peripheral definitions for an Array of Instances."""
    
    children = self.getChildren();
    
    if (len(children) > 1) or not isinstance(children[0], Instance):
        raise OutputterError("Instance Arrays allowed only for single Instances, not groups.", self)
        
    else:
        inst = self.children[0]
        pername = basename + '_' + inst['name']
        print >>output, '__attribute__((unused)) static t_{comp} * const {perarray:25s}= (t_{comp} *){per}_BASE;'.format(
                            comp = inst.binding['name'],
                            perarray = '{0}[{1}]'.format(pername, self['count']),
                            per = pername)
                            
def generate_instance_peripherals(self, basename, output):
    """Create a pointer to the peripheral."""
    pername = basename + '_' + self['name']
    print >>output, '__attribute__((unused)) static t_{comp:12s} * const {per:20s}= (t_{comp} *){per}_BASE;'.format(
                            comp = self.binding['name'],
                            per = pername)
    
    
InstanceArray.generate_peripherals = generate_array_peripherals
Instance.generate_peripherals = generate_instance_peripherals

#
# We need to output MemoryMaps, which will include all of the bound
# Components as either inline text or seperate #include files, plus
# base addressses and pointers to them.
#

def generate_memory_map(mmap, output=sys.stdout):
    """Render down a memory map tree into a python module."""

    header = detab('''
        """
        {name} Memory Map
        Defines all of the {name} components.
        
        {desc}
        
        Generated automatically from {source} on {time}
        Do not modify this file directly.
        
        """
        
        ''').format(
            name = mmap['name'],
            desc = docstring(mmap.getDescription()),
            source = mmap.sourcefile,
            time = datetime.datetime.now().ctime()
        )
    print >>output, header

    references = set(inst.binding for inst in mmap.getChildren())
    
    # Include all of the referenced component headers.
    for inst in references:
        print >>output, 'from {modname} import {ref}'.format(
            modname = inst['name'].lower(),
            ref = inst['name']
        )
    print >>output, ''
    print >>output, '__all__ = [{0}]'.format(','.join(inst['name'] for inst in references))
    

MemoryMap.generate = generate_memory_map

########################################################################
# Main code
########################################################################

def output_select(output_dir, sourcefile):
    """If output_dir is non-null, produce a context manager for
    an output file, with the name derived from output_dir and sourcefile.

    Otherwise, produce a context manager that simply wraps
    the standard output stream.

    """
    class StdoutWrapper:
        def __enter__(self):
            return sys.stdout

        def __exit__(self, type, value, traceback):
            return

    if output_dir:
        return open(make_header_filename(output_dir, sourcefile), 'w')

    else:
        return StdoutWrapper()

def main(argv=None):
    ########################################################
    # Start by parsing the command line options.
    ########################################################
    if argv is None:
        argv = sys.argv[1:]

    ap = argparse.ArgumentParser(description=__doc__)
    ap.add_argument('--output-dir', '-o', help="""
        When present, specifies a directory to write output files to.
        Output files will have the same names as the input files they
        correspond to, but with a .vhd extension, rather than .xml.
        When absent, all output will be written to stdout.
        """)
    ap.add_argument('--no-mmap', '-m', action="store_false", dest = 'mmap', help="""
        Ignore any memory map files; generate only component
        files.
        """)
    ap.add_argument('--external-refs', '-e', action="store_true", dest = 'xrefs', help="""
        If generating a memory map, create all components as seperate
        header files and #include them all.  Default is to put all the
        declarations into one big header file.
        """)
    ap.add_argument('source', nargs = '+', help="""
        Input files in the HTI XML register or memory map description
        format.
        """)

    args = ap.parse_args(argv)

    if (args.output_dir and not os.path.isdir(args.output_dir)):
        print >>sys.stderr, "Unable to write to directory {0}".format(args.output_dir)
        sys.exit(1)

    ########################################################
    # Read all the XML files
    ########################################################

    parser = XmlReader()
    components = []
    maps = []
    codec = codecs.lookup('utf-8')[-1]

    for source in args.source:
        try:
            root = parser.Parse(source)
            if isinstance(root, Component):
                root.finish()
                components.append(root)
            
            elif isinstance(root, MemoryMap):
                maps.append(root)
                
        except:
            print >>sys.stderr, "Error parsing {0}".format(source)
            traceback.print_exc()

    ########################################################
    # Bind the output methods
    ########################################################
    
    HtiElement.textDescription = lambda self: "\n\n".join(self.getDescription())
    
    components_as_files = (not maps) or (not args.mmap) or (args.xrefs)
    
    ########################################################
    # And generate all of the outputs
    ########################################################

    if maps and args.mmap:
        cmap = MemoryMap.build_component_map(components)
        
        for mmap in maps:
            mmap.finish(cmap)
            
            with output_select(args.output_dir, mmap.sourcefile) as target:
                try:
                    mmap.generate(output = codec(target))
                except:
                    print >>sys.stderr, "Error parsing {0}, sourced from {1}".format(
                        mmap['name'], mmap.sourcefile)
                    traceback.print_exc()
                    
    if components_as_files:
        for comp in components:
            with output_select(args.output_dir, comp.sourcefile) as target:
                try:
                    comp.generate(output = codec(target), standalone = True)

                except OutputterError as e:
                    print >>sys.stderr, e.args[0]
                    print >>sys.stderr, '    Sourced from {0}, line {1}'.format(
                                        e.args[1].sourcefile,
                                        e.args[1].sourceline)
                        
                except:
                    print >>sys.stderr, "Unknown error parsing {0}, sourced from {1}".format(
                        comp['name'], comp.sourcefile)
                    traceback.print_exc()

if __name__ == "__main__":
    sys.exit(main())
