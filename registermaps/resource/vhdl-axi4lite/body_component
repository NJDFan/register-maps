library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity {name}_axi4lite is
	port (
		AWADDR	: in  std_logic_vector({addrhigh} downto 0);
		AWPROT	: in  std_logic_vector(2 downto 0);
		AWVALID	: in  std_logic;
		AWREADY	: out std_logic;
		
		WDATA	: in  std_logic_vector({datahigh} downto 0);
		WSTRB	: in  std_logic_vector({behigh} downto 0);
		WVALID	: in  std_logic;
		WREADY	: out std_logic;
		
		BRESP	: out std_logic_vector(1 downto 0);
		BVALID	: out std_logic;
		BREADY	: in  std_logic;
		
		ARADDR	: in  std_logic_vector({addrhigh} downto 0);
		ARPROT	: in  std_logic_vector(2 downto 0);
		ARVALID	: in  std_logic;
		ARREADY	: out std_logic;
		
		RDATA	: out std_logic_vector({datahigh} downto 0);
		RRESP	: out std_logic_vector(1 downto 0);
		RVALID	: out std_logic;
		RREADY	: in  std_logic;
		
		ACLK		: in  std_logic;
		ARESETn	: in  std_logic
	);
end entity {name}_axi4lite;

use work.pkg_{name}.all;

architecture Behavioral of {name}_axi4lite is

	signal reg : t_{name}_regfile := RESET_t_{name}_REGFILE;
	
	signal write_addr : t_addr;
	signal wa_good    : boolean;
	signal write_data : t_busdata;
	signal write_strb : std_logic_vector({behigh} downto 0);
	signal wd_good    : boolean;
	signal bhold : boolean;
	
	constant RESP_OKAY		: std_logic_vector(1 downto 0) := "00";
	constant RESP_EXOKAY	: std_logic_vector(1 downto 0) := "01";
	constant RESP_SLVERR	: std_logic_vector(1 downto 0) := "10";
	constant RESP_DECERR	: std_logic_vector(1 downto 0) := "11";
	
	function SL(x : boolean) return std_logic is
	begin
		if x then return '1';
		else return '0';
		end if;
	end function SL;
	
begin

	-- Manage bus reads.  Reads support 1 in the pipeline, allowing a new
	-- read to be accepted before the read data from the previous has been.
	AXI_READ: process(ACLK)
		variable addr		: t_addr;
		variable dat		: t_busdata;
		variable replying	: boolean;
		variable success	: boolean; 
		
		variable ondeck: boolean;
		variable ondeck_dat  : t_busdata;
		variable ondeck_resp : std_logic_vector(1 downto 0);
	begin
		if rising_edge(ACLK) then
			-- First try to clear the pending read reply.
			if RREADY = '1' then
				replying := false;
			end if;
		
			-- Read the data into the ondeck space.
			if (not ondeck) and (ARVALID = '1') then
				addr := GET_ADDR(ARADDR);
				READ_REGFILE(addr, reg, dat, success);
				
				ondeck := true;
				ondeck_dat := dat;
				if success then ondeck_resp := RESP_OKAY;
				else            ondeck_resp := RESP_SLVERR;
				end if;
			end if;
			
			-- And pass it forward to the reply exchanger when possible.
			if not replying then
				RDATA <= ondeck_dat;
				RRESP <= ondeck_resp;
				replying := ondeck;
				ondeck := false;
			end if;
			
			-- Manage the status flags.
			RVALID  <= SL(replying);
			ARREADY <= SL(not ondeck);
			
			-- And manage reset.
			if ARESETn = '0' then
				replying := false;
				ondeck := false;
				RVALID  <= '0';
				ARREADY <= '0';
			end if;
		end if;
	end process AXI_READ;
	
	-- Manage writes.  Writes support 1 in pipeline support in case acceptance
	-- is slow, but take a clock after both address and data become valid to
	-- execute.
	AXI_WRITE: process(ACLK)
		variable ready		: boolean;
		variable replying	: boolean;
		variable success	: boolean; 
		
		variable ondeck: boolean;
		variable ondeck_resp : std_logic_vector(1 downto 0);
	begin
		if rising_edge(ACLK) then
			-- First try to clear the pending B reply.
			if BREADY = '1' then
				replying := false;
			end if;
			
			-- Process the new write.
			if (not ondeck) and ((AWVALID and WVALID)='1') and (not ready) then
				ready := true;
				UPDATESIG_REGFILE(WDATA, WSTRB, GET_ADDR(AWADDR), reg, success);
	
				ondeck := true;
				if success then ondeck_resp := RESP_OKAY;
				else            ondeck_resp := RESP_SLVERR;
				end if;
			else
				ready := false;
			end if;
			
			-- And pass it forward to the reply exchanger when possible.
			if not replying then
				BRESP <= ondeck_resp;
				replying := ondeck;
				ondeck := false;
			end if;
			
			-- And manage reset.
			if ARESETn = '0' then
				replying := false;
				ondeck   := false;
				ready    := false;
				reg <= RESET_t_{name}_REGFILE;
			end if;
			
			AWREADY <= SL(ready);
			WREADY  <= SL(ready);
			BVALID  <= SL(replying);
		end if;
	end process AXI_WRITE;
	
end architecture Behavioral;
